学习笔记

## JavaScript对象：我们真的需要模拟类吗？
原型系统，是一个非常优秀的抽象对象的形式。

**什么是原型？**
“基于原型”的编程看起来更为提倡程序员去关注一系列对象实例的行为，
而后采取关系如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。

**JavaScript的原型**
JS的原型系统：
* 如果所有对象都有私有字段[[prototype]]，就是对象的原型；
* 读一个属性，如果对象本身没有，则会继续访问对象的原型，知道原型为空或者找到为止。

**ES6中的类**
在任何场景，都推荐使用ES6的语法来定义类，而令function回归原本的函数语义。
类的写法实际上也是由原先运行时来承载的，逻辑上JavaScript认为每个类都是有共同原型的一组对象，类中
定义的方法和属性则会被写原型对象之上。

当我们使用类的思想来设计代码时，应该尽量使用class来声明类，而不是用就语法，拿函数来模拟对象。

## JavaScript对象：你知道全部的对象分类吗？

**JavaScript中的对象分类**
* 宿主对象（host Objects）：有JavaScript宿主环境提供的对象，他们的行为完全由宿主环境决定。
* 内置对象（Built-in Object）由JavaScript语言提供的对象。

   * 固有对象（Intrinsic Objects）：由标准规定，随着JavaScript运行时创建二自动创建的对象实例。

   * 原生对象（Native Objects）：可以由用户通过Array、RegExp等内置构造器或者特殊语法创建的对象。

   * 普通对象（Ordinary Objects）：由{}语法、Object构造器或者class关键字定义类创建的对象，它能够被原型继承。

**宿主对象**
浏览器全局对象window上的属性，一部分来自JavaScript语言，一部分来自浏览器环境。

**内置对象-固有对象**
固有对象在任何JavaScript代码执行前就已经被创建出来了，他们通常扮演着类似基础库的角色。

**用对象来模拟函数与构造器：函数对象与构造器对象**
函数对象的定义：具有[[call]]私有字段的对象，构造器对象的定义是：具有使用字段[[construct]]的对象。

**特殊行为的对象**

* Array: Array的length属性根据最大的下标自动发生变化。
* Object.prototype: 作为所有正常对象的默认原型，不能再给他设置原型了。
* String: 为了支持下标运算，String的正整数属性访问会去字符串里查找。
* Arguments: arguments的非负整数型下标属性根对应的变量联动。
* 模块的namespace对象：特殊的地方很多，跟一般对象完全不一样，尽量只用于import吧。
* 类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。
* bind后的function: 跟原来的函数相关联。

## JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？
一个JavaScript引擎会常驻于内存中，它等待着我们（宿主）把JavaScript代码或者函数传递给它执行。

采纳JSC引擎的术语，我们把宿主发起的任务称为宏观任务，把JavaScript引擎发起的任务称为微观任务。

**宏观和微观任务**
在宏观任务中，JavaScript的Promise还会产生异步代码，JavaScript必须保证这些异步代码在一个宏观任务完成，
因此，每个宏观任务中又包含一个微观任务队列。

**Promise**
Promise的resolve始终是异步操作。
微任务有限。

如何分析异步执行的顺序：
* 首先我们分析有多少个宏任务；
* 在每个宏任务中，分析有多少个微任务；
* 根据调用次序，确定宏任务中的微任务的执行次序；
* 根据宏任务的触发规则和调用次序，确定宏任务的执行次序；
* 确定整个顺序。

## JavaScript执行（二）：闭包和执行上下文到底是怎么回事？

**闭包**
闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数
的区别是，它携带了执行的环境，就像人在外星中需要自大吸氧的装备一样，这个函数也带有在程序中生存的环境。

在JavaScript中对应的闭包组成部分：
* 环境部分
   * 函数的词法环境（执行上下文的一部分）
   * 标识符列表：函数中用到的未声明的变量
* 表达式部分：函数体

实际上JavaScript中跟闭包对应的概念就是”函数“。

**执行上下文：执行的基础设施**
JavaScript中闭包“环境部分”相对于的术语是“词法环境”，但是JavaScript函数要比λ函数要复杂的多，
我们还要处理this、变量声明、with等等一系列的复杂语法，λ函数中可没有这些东西，所以，在JavaScript
的设计中，词法环境只是JavaScript执行上下文的一部分。

JavaScript标准把一段代码（包括函数），执行所需的所有信息定义为：”执行上下文“。

ES2018中的执行上下文：
* lexical environment: 词法环境，当获取变量或者this值时使用。
* variable environment: 变量环境，当声明变量时使用。
* code evaluation state: 用于恢复代码执行位置。
* Function: 执行的任务是函数时使用，表示正在被执行的函数。
* ScriptOrModule: 执行的任务是脚本或者模块时使用，表示正在被执行的函数。
* Realm: 使用的基础库和内置对象实例。
* Generator: 仅生成器上下文有这个属性，表示当前生成器。

**var声明与赋值**
var声明作用域函数执行的作用域。也就是说var会穿透for、if、with等语句。

括号有个缺点，那就是如果上一行代码不写分号，括号会被解释为上一行代码最末的函数调用。
立即执行的函数表达式推荐写法：
```
void function() {
    var a;
    // code
}();
```

**let**
为了实现let，JavaScript在运行时引入了块级作用域。也就是说，在let出现之前，JavaScript的if for
等语句皆不产生作用域。

以下语句会产生let使用的作用域：
* for
* if 
* switch
* try/catch/finally

**Realm**
Realm中包含一组完整的内置对象，而且是复制关系。

## JavaScript执行（三）：你知道现在有多少中函数吗？
**函数**

1. 普通函数：用function关键字定义的函数。
2. 箭头函数：用=>运算定义的函数。
3. 方法：在class中定义的函数。
4. 生成器函数：用function* 定义的函数。
5. 类：用class定义的类，实际上也是函数。
6. 第六/七/八种，异步函数：普通函数、箭头函数和生成器函数加上async 关键字。

**this关键字的行为**

普通函数的this值由“调用它所使用的引用”决定，其中奥秘就在于：我们获取函数的表达式，它实际上返回的并非
函数本身，而是一个Reference类型。
Reference类型由两部分组成：一个对象和一个属性值。

调用函数时使用的引用，决定了函数执行时刻的this的值。

实际上从运行时的角度来看，this跟面向对象毫无关联，它是与函数调用时使用的表达式相关。

生成器函数、异步生成器函数和异步普通函数跟普通函数行为是一致的，异步箭头函数与箭头函数行为是一致的。

**this关键字的机制**
在JavaScript标准中，为函数规定了用来保存定义时上下文的私有属性[[Envirnment]]。

当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（out lexical environment）会被
设置成函数的[[Environment]]。

这个动作就是切换上下文。

Java标注定义了[[thisMode]]私有属性：
* lexical: 表示上下文中找this，这对应了箭头函数。
* global: 表示this为undefined时，取全局对象，对应了普通函数。
* strict: 当严格模式时使用，this严格按照调用时传入的值，可能为null或者undefined。

非常有意思的是，方法的行为跟普通函数有差异，恰恰是因为class涉及成了默认按strict模式执行。

函数创建新的执行上下文中的词法环境记录时，会根据[[thisMode]]来标记新记录的[[ThisBindingStatus]]
私有属性。

代码执行遇到this时，会逐层检查当前词法环境记录中的[[ThisBindingStatus]]，当找到有this的环境记录时获取
this的值。

仅普通函数和类能够跟new搭配使用。

## JavaScript执行（四）：try里面放return，finally还会执行吗？

**Completion 类型**
Completion Record用于描述异常、跳出等语句执行过程。

Completion Record表示一个语句执行完之后的结果，它有三个字段：
* [[type]]表示完成的类型，有break continue return throw和normal几种类型；
* [[value]]表示语句的返回值，如果语句没有则是empty；
* [[target]]表示语句的目标，通常是一个JavaScript标签。

**语句块**
return 语句可能产生return或者throw类型的Completion Record。
非normal的完成类型可以穿透复杂的语句嵌套结构，产生控制效果。

因为finally中的内容必须保证执行，所以try/catch执行完毕，即使得到的结果是非normal型的完成记录。也必须要执行finally。

而当finally执行也得到了非normal记录，则会使finally中的记录作为整个try结构的结果。

**带标签的语句**
大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是：与完成记录类型的target相配合，用于跳出多层循环。

## JavaScript词法：为什么12.toString会报错？

文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。

词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”。

## (小实验)理解编译原理：一个四则运算的解释器









