# 浏览器工作原理

## 1. 浏览器工作原理
浏览器从一个URL到显示一个页面流程如下：
1. URL通过HTTP协议解析得到HTML；
2. HTML经过解析得到DOM树；
3. DOM树通过CSS计算得到带CSS样式的DOM树；
4. DOM树再经过排版得到带位置的DOM树；
5. DOM树通过渲染的到位图展示给用户；

## 2. 状态机
状态机部分是通过有限状态机处理字符串进行学习的。

有限状态机中，每个状态都是一个机器，在每一个机器中，我们可以做计算、存储、输出等等；所有的这些机器接受的输入是一致的；状态机的每一个机器本身没有状态，如果我们函数来表示的话，它应该是纯函数（无副作用）。

**每一个机器知道下一个状态：**
* 一种是每个机器都有确定的下一个状态（Moore），下一个状态和输入无关；
* 另一种是每个机器依据输入决定下一个状态（Mealy）

我们通过好几个查找字符串的例子进行了实战学习，先是查找几个确定的字符串，引出重复消费的概念，也就是中间状态机的下一个状态可能会让之前的机器再次消费当前字符。

终极案例是查找不确定的字符串，此时我们是无法知道在查找字符串的过程中会出现哪些状态，以及中间状态的下一状态。此时借助了KMP算法，在匹配子串时，遇到当前字符不匹配的情况时，实际上我们已经知道前面已经匹配了哪些字符，被匹配字符串不一定会再从最前端重新匹配一遍。这可以使用状态机的再次消费进行表示。

通过这几个实战案例练习，理论+实践，对状态机有一个更深的理解。

## 3. HTTP请求

HTTP请求包含两个部分：
* Request
* Response

**Request**
一个请求中主要包含三个部分：
* 请求行
   * 请求方法
   * 请求路径
   * HTTP协议版本

* 请求头，长度不定
    * 必须包含Content-Type
* 空行分隔
* 请求体
    可以为空

**Response**
一个响应主要包含三个部分：
* 状态行
   * HTTP的版本号
   * 状态码，500系列服务器内部错误、200、404等
   * 状态文本
* 空行分隔
* 响应头
* 响应体

### 3.1 HTTP请求
* 设计一个HTTP请求的类
* Content-Type是一个必要的字段，要有默认值
* body是KV格式
* 不同的Content-Type影响body的格式

### 3.2 send函数
* 在Request的构造器中收集必要的信息
* 设计一个send函数，把请求正式发送到服务器
* send函数应该是异步的，所以返回Promise

## 3.3 发送请求
* 设计支持已有的connection或者自己新建connection
* 收到数据传给parser
* 更具parser的状态resolve Promise